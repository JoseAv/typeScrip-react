# Record Type

Este es un elemento que nos ayuda a definir una estructura de tipo clave valor

Ejemplo

``` ts
type confi = {
    user: Record<string,string>
}
```

aqui definimos un objeto clave valor que su clave es un string y su valor es un string como estos

``` ts
const user = {name:'Jose'}

// ❌ Esto no estaria correcto
const user = {name: 2}

```
pero yo defini string, string pero lo que tengo es name: 'Jose' que Jose si seria string pero tambien tambien, en js las claves de los objetos son de tipo string.

# Utilidad

Pero podriamos pensar que es mas facil simplemente crear la interfas de esta forma

``` js
type user = {name:string}

```
y asi podriamos ir extendiendo, en realidad el record es mas utilizado para indicar que tipo de claves puede usar

Ejemplo

``` js
type typeuser = Record<'Jose'| 'Alberto', string>
```

entonces cuando ahora pasemos el objeto tiene que estar definido asi

``` js
// esto es lo que definimos con el record
type typeuser = Record<'Jose'| 'Alberto', string>

// esta es la implementacion
const user: typeuser = {Jose:'text', Alberto: 'text'}

```

## Cuando usar

Ahora como podemos hemos podido ver los ejemplos son facilmente cambiados por una interfaces y hasta seria mas facil pero aqui voy a explicar cuando y porque usar record en ves de un type o interface

- 1. No sabemos cuales son las claves por ejemplo

``` js

const users: UserById = {
  'abc123': { name: 'Jose', age: 25 },
  'def456': { name: 'Maria', age: 30 },
  'xyz789': { name: 'Carlos', age: 28 },
}

```

aqui no podemos saber que keys seran pero la estructura si es muy util ya que es O(1) en tiempo y espacio

- 2. Las keys vienen dadas por otro lugar

``` js
// Las keys vienen de una API o constante
const ALLOWED_ROLES = ['admin', 'user', 'guest'] as const
type Role = typeof ALLOWED_ROLES[number] // 'admin' | 'user' | 'guest'

// ✅ Ahora Record tiene sentido porque las keys ya existían
type Permissions = Record<Role, string[]>
```

# Resumen

Conclusión final:

- 1. Keys fijas y conocidas: Usa interface o type normal → más simple

- 2. Keys dinámicas (string genérico): Usa Record → única opción práctica

- 3. Reutilizar types existentes: Record puede ser útil

- 4. Todo lo demás: Probablemente interface/type es más claro