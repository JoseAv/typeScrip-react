# Generics
Son una forma de nosotros indicar que valor vamos a pasar, asi podemos reutilizar, types,funciones, interfaces, etc...


### Funciones
```ts

// Funcion normal
const values = (val)=>{
    return val
}

// Funcion Generica

const values = <T>(val: T): T=>{
    return val
}
// Aplicacion

values<string>('hola')
values<number>(200)
values<number[]>([200,300])

```

### Types o interfaces

```ts
type user<T> = {
    name:string
    code:T
}

interface user<T> = {
    name:string
    code: T
}

// Aplicacion

const newUser: user<string> = {name:'jose', code:'123'}
const newUserNumber: user<number> = {name:'jose', code:123}

```

## Otros Funciones

Tambien podemos usar varios genericos

```ts
type user<T, U> = {
    name:U
    code:T
}

```

Los genericos tambien pueden extender de otro tipo de dato por ejemplo

``` ts
type user<T extends number, U> = {
    name:U
    code:T
}

```

Esto hace que extend sea de tipo number cualquier numero si bien esto no tiene mucho sentido veamoslo con un objeto y que pasa si no extendemos de un objeto

``` ts
// Sin extends

type user<T, U> = {
    name:T
    code:U
}

type codeValues = {status:number, message:string}

// Creamos el objeto
const newUser: user<string,codeValues> = {name:'jose', code: {status:200,message:'Exito'}}

// ahora si intentamos esto

newUser.code.message // ❌ Error
newUser.code.status //  ❌ Error 

// porque T puede ser un objeto o no, tu ya le indicaste que es un objeto pero tambien puedes crear uno que no es tipo objeto 

const newUser: user<string,number> = {name:'jose', code: 200}

// Esto tambien es valido entonces TS no sabe si es un objeto y tendria que coprobarlo


// Con extends

type user<T, U extends object> = {
    name:U
    code:T
}

// ahora pasamos algo asi
type codeValues = {status:number, message:string}
const newUser: user<string,codeValues> = {name:'jose', code: {status:200,message:'Exito'}}

newUser.code.message // ✅ Funciona
newUser.code.status  // ✅ Funciona 

// Ahora si funciona porque tu ya le dijiste a T que puede ser cualquier objeto pero debe de ser objeto no aceptara otro valor como

const newUser: user<string, number> = {name:'jose', code: 200} // Error Code debe de ser un objeto


```



En resumen: extends object le dice a TypeScript que el tipo genérico debe ser un objeto, lo que te permite usar operaciones de objetos y acceder a sus propiedades con seguridad de tipos. Sin esto, TypeScript no puede garantizar que T sea un objeto y no te dejará hacer ciertas operaciones.

### Extends de Literales

Los genericos tambien nos permite extends de los primitivos si bien extender de tipos objetos o arrays tiene sentido para que el pueda usar sus propiedades, tambien podemos extender de primitivos y si podemos hacer seto


``` ts
type numbers<T extends number> = {
    code:T
}

```

esto seria lo mismo que decir que code es tipo number y no tiene mucho sentido pero tiene mas utilidad cuando hacemos esto

``` ts
type numbers<T extends 200 | 300 | 500> = {
    code:T
}

```
Ahora code solo puede ser esos numeros que heredo de number y esto si es mucho mas util y mejor para poder utilizarlo.


### Tips

Si bien aqui cubrimos varios casos hay que tener cuidado ya que TS no puede saber que operaciones hace T lo recomendable seria Comprobar con typeof que tipo de dato es, o extender los primitivos pero igualmente puede ser bastante Dificil


``` ts

type Data<T> = {
    code: T
}

function processData<T>(data: Data<T>) {
    // ✅ Verificación en tiempo de ejecución
    if (typeof data.code === 'number') {
        // Ahora TypeScript sabe que es number
        console.log(data.code.toFixed(2))
        console.log(data.code + 10)
    }
    
    if (typeof data.code === 'string') {
        console.log(data.code.toUpperCase())
        console.log(data.code.length)
    }
    
    if (Array.isArray(data.code)) {
        console.log(data.code.map(x => x))
        console.log(data.code.length)
    }
    
    if (typeof data.code === 'object' && data.code !== null) {
        console.log(Object.keys(data.code))
    }
}


```

o puedes usar librerias para verificar como ZOD.