# Interface vs Type

En esencia son lo mismo con algunas diferencias interesantes en ellas pero las 2 nos permiten tipar nuestros objetos o valores y un uso diferentes que vamos a ver mas adelante.

## Interface

Una interfaces es solo para colocar un tipo a un objeto y solo a un objeto.

Ejemplo: 

``` ts
// Interfaces normal
interface user {
    name:string
    age:number
}

// Interfaces Generica

interface user<T, U>{
    name: T
    age: U
}
```

Esto es bastante util para tipar objetos pero nos limita solo a ellos tambien son bastante faciles de extender.

### Union de interfaces

Si queremos unir interfaces usamos la palabra clave extends es decir va a tomar las propiedades y las va  extender a la nueva 

Ejemplo: 


```ts

interface Iuser {
    name:string
    age:number
}

// al extender una interfaces de esto
interface UserWithId extends Iuser {
    id:number
}


// esto seria el resultado visual esta seria la interface que creamos
{
    name:string
    age:number
    id:number
}


```

# Types

types es otra forma de tipar datos esta es bastante util ya que sirve tanto para objetos como para un valor primitivo suelto

Ejemplo

```ts
// tipando un solo elemento
type color = 'red' | 'yellow'

// tipando varios
type Respuesta = {
  data: T;
  success: boolean;
  message: string;
}

// Generico
type Respuesta<T> = {
  data: T;
  success: boolean;
  message: string;
}

```



Ahora si nosotros queremos extender es decir crear una interfaces uniendo 2 tipos para crear solo 1 se hace de esta forma

```ts
// tipando un solo elemento
type color = {name:string}

// tipando varios
type Respuesta = {
  data: T;
  success: boolean;
  message: string;
}

type Union = color & Respuesta

```

esto es lo mismo que como se hace en interfaces pero mucho mas corto 

## Reglas de &

al hacer uniones con & podemos pensar o cometer el error de juntar 2 tipos diferentes como primitivo con objeto o array con objeto esto nos devolvera un tipo never

ejemplo

```ts
type Color = 'red' | 'yellow';

type Respuesta = {
  data: string;
  success: boolean;
  message: string;
}

type Union = Color & Respuesta;
// ❌ Esto resulta en `never` porque es IMPOSIBLE satisfacer ambos
```

Si bien esto no puede satisfacer a ambas no puede ser objeto o string el operador Union | si puede ser esto, darnos la posibilidad de ser un primitivo o un objeto o cualquier tipo de dato.

Ejemplo:

```ts
type Color = 'red' | 'yellow';

type Respuesta = {
  data: string;
  success: boolean;
  message: string;
}

// ✅ Puede ser Color O Respuesta
type ColorORespuesta = Color | Respuesta;

const opcion1: ColorORespuesta = 'red';  // ✅

const opcion2: ColorORespuesta = {       // ✅
  data: "algo",
  success: true,
  message: "ok"
}

```

## Tips

Cuando nosotros queremos definir un valor y solo un valor es mejor hacerlo con un type pero puede ocurrir ciertas cosas como en este ejemplo


``` ts

interface sizes {
    size: 'X' | 'L'
}

interface Usuario {
  nombre: string;
  email: string;
  size: sizes;
}

// si nosotros hacemos esto crearemos una interfaces de este tipo

 {
    nombre: string,
    email:string
    size: {size: 'X' | 'L'}
}


// Esto podria ser algo que no queramos y solo queremos que size tenga este tipo, podemos hacerlo directamente como este caso 

interface Usuario {
  nombre: string;
  email: string;
  size: 'X' | 'L';
}

// pero pueda ser que queramos estos tipos en otro lado entonces es mejor crear un type de esta forma


type  sizes= {
    size: 'X' | 'L'
}

interface Usuario {
  nombre: string;
  email: string;
  size: sizes;
}

```